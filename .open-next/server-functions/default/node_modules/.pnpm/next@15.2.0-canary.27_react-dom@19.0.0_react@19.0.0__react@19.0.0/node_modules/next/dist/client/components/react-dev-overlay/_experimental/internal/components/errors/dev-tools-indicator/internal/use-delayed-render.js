"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useDelayedRender", {
    enumerable: true,
    get: function() {
        return useDelayedRender;
    }
});
const _react = require("react");
function useDelayedRender(active, options) {
    if (active === void 0) active = false;
    if (options === void 0) options = {};
    const [, force] = (0, _react.useState)();
    const mounted = (0, _react.useRef)(active);
    const rendered = (0, _react.useRef)(false);
    const renderTimer = (0, _react.useRef)(null);
    const unmountTimer = (0, _react.useRef)(null);
    const prevActive = (0, _react.useRef)(active);
    const recalculate = (0, _react.useCallback)(()=>{
        const { enterDelay = 1, exitDelay = 0 } = options;
        if (prevActive.current) {
            // Mount immediately
            mounted.current = true;
            if (unmountTimer.current) clearTimeout(unmountTimer.current);
            if (enterDelay <= 0) {
                // Render immediately
                rendered.current = true;
            } else {
                if (renderTimer.current) return;
                // Render after a delay
                renderTimer.current = setTimeout(()=>{
                    rendered.current = true;
                    renderTimer.current = null;
                    force({});
                }, enterDelay);
            }
        } else {
            // Immediately set to unrendered
            rendered.current = false;
            if (exitDelay <= 0) {
                mounted.current = false;
            } else {
                if (unmountTimer.current) return;
                // Unmount after a delay
                unmountTimer.current = setTimeout(()=>{
                    mounted.current = false;
                    unmountTimer.current = null;
                    force({});
                }, exitDelay);
            }
        }
    }, [
        options
    ]);
    // When the active prop changes, need to re-calculate
    if (active !== prevActive.current) {
        prevActive.current = active;
        // We want to do this synchronously with the render, not in an effect
        // this way when active → true, mounted → true in the same pass
        recalculate();
    }
    return {
        mounted: mounted.current,
        rendered: rendered.current
    };
}

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=use-delayed-render.js.map